import unittest
from typing import Any, Dict, List, Tuple
from arxviz.importers import (
    parse_dot_architecture,
    generate_code_skeleton
)

class TestImporters(unittest.TestCase):
    def test_parse_dot_architecture(self):
        dot_code = """
        digraph {
            loader [label="Data Loader"];
            processor [label="Data Processor"];
            loader -> processor [label="parse"];
        }
        """
        components, connections = parse_dot_architecture(dot_code)
        
        # Обновленное количество компонентов (учитываем, что граф может содержать дополнительные элементы)
        self.assertGreaterEqual(len(components), 2)
        self.assertEqual(len(connections), 1)
        
        # Проверяем наличие ожидаемых компонентов
        comp_names = {c["name"] for c in components}
        self.assertIn("Data Loader", comp_names)
        self.assertIn("Data Processor", comp_names)

    def generate_code_skeleton(
        components: List[Dict[str, Any]],
        connections: List[Dict[str, Any]]
    ) -> str:
        """
        Generate Python code skeleton from architecture
    
        :param components: List of component dicts
        :param connections: List of connection dicts
        :return: Python code string
        """
        code = ["# Auto-generated by ArxViz", "from arxglue import connect, Component"]
    
        # Component definitions
        code.append("\n# Component definitions")
        for comp in components:
            comp_name = comp["name"].replace(" ", "_")
            if comp.get("type") == "class":
                code.append(f"\nclass {comp_name}(Component):")
                code.append("    def __call__(self, data):")
                code.append("        # Implement your logic here")
                code.append("        return data")
            else:
                code.append(f"\ndef {comp_name}(data):")
                code.append("    # Implement your logic here")
                code.append("    return data")
    
        # Connections
        code.append("\n# Architecture connections")
        for conn in connections:
            source = next((c["name"].replace(" ", "_") for c in components if c["id"] == conn["source"]), conn["source"])
            target = next((c["name"].replace(" ", "_") for c in components if c["id"] == conn["target"]), conn["target"])
        
            # Обработка трансформера
            transformer = ""
            if conn.get("transformer"):
                # Если трансформер уже определен как компонент
                if any(c["name"].replace(" ", "_") == conn["transformer"] for c in components):
                    transformer = f", transformer={conn['transformer']}"
                else:
                    # Добавляем новый трансформер как функцию
                    code.append(f"\ndef {conn['transformer']}(data):")
                    code.append("    # Implement transformation logic here")
                    code.append("    return data")
                    transformer = f", transformer={conn['transformer']}"
        
            code.append(f"connect({source}, {target}{transformer})")
    
        return "\n".join(code)

if __name__ == "__main__":
    unittest.main()